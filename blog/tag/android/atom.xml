<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://nuitka.net</id>
  <title>Nuitka Blog - Posts tagged Android</title>
  <updated>2022-06-14T19:29:20.896245+00:00</updated>
  <link href="https://nuitka.net"/>
  <link href="https://nuitka.net/blog/tag/android/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.org/" version="0.10.25">ABlog</generator>
  <entry>
    <id>https://nuitka.net/posts/letting-go-of-c11.html</id>
    <title>Letting go of C++11</title>
    <updated>2012-10-27T08:59:07+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;p&gt;How Nuitka came to use C++11 and then stop it.&lt;/p&gt;
&lt;section id="letting-go-of-c-11"&gt;

&lt;p&gt;This post is about Nuitka the Python compiler started out using C++0x
which is now C++11, and then chose to stop it.&lt;/p&gt;
&lt;section id="in-the-beginning"&gt;
&lt;h2&gt;In the Beginning&lt;/h2&gt;
&lt;p&gt;Very early on, when I considered how to generate code from the node
tree, in a way, that mistakes should practically be impossible to make,
I made the fundamental decision, that every Python expression, which
produces temporary variables, should become an expression in the
generated code too.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;That is my choice, I think it keeps code generation more simple, and
easier to understand. There may come a separate post about how that
played out.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;That decision meant some trouble. Certain things were not easy, but
generally, it was achievable for g++ relatively quickly, and then lots
of helper functions would be needed. Think of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MAKE_TUPLE&lt;/span&gt;&lt;/code&gt; and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MAKE_DICT&lt;/span&gt;&lt;/code&gt;, but also other stuff needed that. Calling a Python
built-in with variable number of parameters e.g. could be implemented
that way easily.&lt;/p&gt;
&lt;p&gt;Other nice things were &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;enum&lt;/span&gt;&lt;/code&gt; classes, and generally good stuff. It
was really quick to get Nuitka code generation off the ground this way.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="reality-strikes"&gt;
&lt;h2&gt;Reality Strikes&lt;/h2&gt;
&lt;p&gt;But then, as time went on, I found that the order of evaluation was
becoming an issue. It became apparent that for more and more things, I
needed to reverse it, so it works. Porting to ARM, it then became clear,
that it needs to be the other way around for that platform. And checking
out clang, which is also a C++11 compiler, I noticed, this one yet uses
a different one.&lt;/p&gt;
&lt;p&gt;So, for normal functions, I found a solution that involves the
pre-processor to reverse or not, &lt;em&gt;both&lt;/em&gt; function definition and call
sites, and then it is already correct.&lt;/p&gt;
&lt;p&gt;This of course, doesn’t work for C++11 variadic functions. So, there
came a point, where I had to realize, that each of its uses was more or
less causing evaluation order bugs. So that most of their uses were
already removed. And so I basically knew they couldn’t stay that way.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="other-features"&gt;
&lt;h2&gt;Other Features&lt;/h2&gt;
&lt;p&gt;Also, things I initially assumed, e.g. that lambda functions of C++11
may prove useful, or even “auto”, didn’t turn out to be true. There
seemingly is a wealth of new features, besides variadic templates that I
didn’t see how Nuitka would benefit from it at all.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="new-wishes"&gt;
&lt;h2&gt;New Wishes&lt;/h2&gt;
&lt;p&gt;Then, at Europython, I realized, that Android is still stuck with
g++-4.4 and as such, that an important target platform will be
unavailable to me. This platform will become even more important, as I
intend to buy an device now.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="biting-it"&gt;
&lt;h2&gt;Biting it&lt;/h2&gt;
&lt;p&gt;So what I did, was to remove all variadic functions and instead generate
code for them as necessary. I just need to trace the used argument
counts, and then provide those, simple enough.&lt;/p&gt;
&lt;p&gt;Also, other things like deleted copy constructors, and so on, I had to
give up on these a bit.&lt;/p&gt;
&lt;p&gt;This change was probably suited to remove subtle evaluation order
problems, although I don’t recall seeing them.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-present"&gt;
&lt;h2&gt;The Present&lt;/h2&gt;
&lt;p&gt;The current stable release still requires C++11, but the next release
will work on g++-4.4 and compiles fine with MSVC from Visual Studio
2008, although at this time, there is still the issue of generators not
working yet, but I believe that ought to be solvable.&lt;/p&gt;
&lt;p&gt;The new requirement is only C++03, which means, there is a good chance
that supporting Android will become feasible. I know there is interest
from App developers, because there, even the relatively unimportant 2x
speedup, that Nuitka might give for some code, may matter.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So that is a detour, I have taken, expanding the base of Nuitka even
further. I felt, this was important enough to write down the history
part of it.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/letting-go-of-c11.html" rel="alternate"/>
    <summary>How Nuitka came to use C++11 and then stop it.</summary>
    <category term="Nuitka" label="Nuitka"/>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Windows" label="Windows"/>
    <category term="Android" label="Android"/>
    <published>2012-10-27T08:59:07+00:00</published>
  </entry>
</feed>
