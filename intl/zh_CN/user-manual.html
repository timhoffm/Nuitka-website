<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
    <link rel="icon" href="_static/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="_static/favicon.png" sizes="32x32" type="image/png">
    <link rel="icon" href="_static/favicon.ico" sizes="32x32" type="image/x-icon">
    <link rel="icon" href="_static/apple-touch-icon-iphone.png" sizes="57x57" type="image/png">
    <link rel="icon" href="_static/apple-touch-icon-ipad.png" sizes="72x72" type="image/png">
    <link rel="icon" href="_static/apple-touch-icon-iphone4.png" sizes="114x114" type="image/png">
    <link rel="icon" href="_static/apple-touch-icon-ipad3.png" sizes="144x144" type="image/png">
    <link rel="apple-touch-icon" href="_static/apple-touch-icon-180x180.png" sizes="180x180" type="image/png">

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nuitka 用户手册</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="_static/my_theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/design-style.59c74d8c95b765a7fd995ac71d459ebe.min.css" type="text/css" />
    <link rel="canonical" href="https://nuitka.net/zh_CN/user-manual.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script src="_static/translations.js"></script>
        <script src="_static/design-tabs.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="支持" href="support.html" />
    <link rel="prev" title="下载 Nuitka" href="download.html" />   
<link
  rel="alternate"
  type="application/atom+xml"
  href="posts/atom.xml"
  title="Nuitka Blog"
/>
 
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Nuitka the Python Compiler
            <img src="_static/Nuitka-Logo-Symbol.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="start.html">快速入门</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="download.html">下载</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">用户手册</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">概览</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usage">语法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#requirements">需求</a></li>
<li class="toctree-l4"><a class="reference internal" href="#command-line">命令行</a></li>
<li class="toctree-l4"><a class="reference internal" href="#installation">安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="#license">许可证</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tutorial-setup-and-build-on-windows">教程设置和在 Windows 上构建</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#setup">设置</a></li>
<li class="toctree-l4"><a class="reference internal" href="#write-some-code-and-test">编写一些代码并进行测试</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#use-cases">用例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#use-case-1-program-compilation-with-all-modules-embedded">用例 1 - 嵌入所有模块的程序编译</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-case-2-extension-module-compilation">用例2 – 扩展模块的编译</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-case-3-package-compilation">用例3–软件包的编译</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-case-4-program-distribution">用例4–程序分发</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-case-5-setuptools-wheels">用例5 - Setuptools 轮子</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tweaks">调整</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#icons">图标</a></li>
<li class="toctree-l4"><a class="reference internal" href="#splash-screen">闪屏</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#typical-problems">典型问题</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memory-issues-and-compiler-bugs">内存问题和编译器错误</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-sys-path">动态 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#missing-data-files-in-standalone">单机版中缺少的数据文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#missing-dlls-in-standalone">单机中缺少 DLLs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dependency-creep-in-standalone">单机中的依赖性爬升</a></li>
<li class="toctree-l4"><a class="reference internal" href="#onefile-finding-files">一体化文件：寻找文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#windows-programs-without-console-give-no-errors">没有控制台的 Windows 程序不会出现错误</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tips">小贴士</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#nuitka-options-in-the-code">代码中的 Nuitka 选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#python-command-line-flags">Python 命令行旗标</a></li>
<li class="toctree-l4"><a class="reference internal" href="#caching-compilation-results">缓存编译结果</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-where-caches-live">控制缓存的位置</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runners">运行器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fastest-c-compilers">最快的 C 语言编译器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unexpected-slowdowns">意外的速度减慢</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standalone-executables-and-dependencies">独立的可执行文件和依赖性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#windows-errors-with-resources">资源方面的 Windows 错误</a></li>
<li class="toctree-l4"><a class="reference internal" href="#windows-standalone-program-redistribuation">Windows 独立程序的重新分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="#detecting-nuitka-at-run-time">在运行时检测 Nuitka</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#performance">性能</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pystone-results">pystone 结果</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#where-to-go-next">下一步该去哪里</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#follow-me-on-twitter">在 Twitter 上关注我</a></li>
<li class="toctree-l4"><a class="reference internal" href="#report-issues-or-bugs">报告问题或 bug</a></li>
<li class="toctree-l4"><a class="reference internal" href="#word-of-warning">警示语</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#join-nuitka">加入 Nuitka</a></li>
<li class="toctree-l3"><a class="reference internal" href="#donations">奉献</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unsupported-functionality">不支持的功能</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-co-code-attribute-of-code-objects">代码对象的 <code class="docutils literal notranslate"><span class="pre">co_code</span></code> 属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pdb">PDB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#optimization">优化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constant-folding">常量叠算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constant-propagation">常量传播</a></li>
<li class="toctree-l4"><a class="reference internal" href="#built-in-name-lookups">内置名称查询</a></li>
<li class="toctree-l4"><a class="reference internal" href="#built-in-call-prediction">内置回调预测</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conditional-statement-prediction">条件性声明的预测</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exception-propagation">异常传播</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exception-scope-reduction">Exception Scope Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exception-block-inlining">Exception Block Inlining</a></li>
<li class="toctree-l4"><a class="reference internal" href="#empty-branch-removal">Empty Branch Removal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unpacking-prediction">Unpacking Prediction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#built-in-type-inference">Built-in Type Inference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quicker-function-calls">Quicker Function Calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lowering-of-iterated-container-types">Lowering of iterated Container Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#updates-for-this-manual">更新手册</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="support.html">支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="roadmap.html">路线图</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="commercial.html">Nuitka Commercial</a></li>
<li class="toctree-l1"><a class="reference internal" href="more.html">更多内容</a></li>
<li class="toctree-l1"><a class="reference internal" href="blog.html">Nuitka Blog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Nuitka the Python Compiler</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="start.html">快速入门</a> &raquo;</li>
      <li>Nuitka 用户手册</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
              <section id="nuitka-user-manual">
<h1>Nuitka 用户手册<a class="headerlink" href="#nuitka-user-manual" title="永久链接至标题"></a></h1>
<section id="overview">
<h2>概览<a class="headerlink" href="#overview" title="永久链接至标题"></a></h2>
<p>如果你对使用 Nuitka 感兴趣，建议首先阅读这份文档，了解它的使用情况，检查你可以期待什么，许可证，要求，信用等等。</p>
<p>Nuitka is <strong>the</strong> Python compiler. It is written in Python. It is a
seamless replacement or extension to the Python interpreter and compiles
<strong>every</strong> construct that CPython 2.6, 2.7, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8,
3.9, 3.10 have, when itself run with that Python version.</p>
<p>然后它以一种极其兼容的方式将未编译的代码和已编译的代码一起执行。</p>
<p>你可以自由使用所有 Python 库模块和所有扩展模块。</p>
<p>Nuitka 将 Python 模块翻译成 C 级程序，然后使用 <code class="docutils literal notranslate"><span class="pre">libpython</span></code> 和自己的静态 C 文件，以 CPython 的方式执行。</p>
<p>所有的优化都是为了避免开销，在没有必要的地方。没有任何优化是为了消除兼容性，虽然偶尔会做一些轻微的改进，但并不是标准 Python 的每一个错误都被模拟，例如给出更完整的错误信息，但有一个完全的兼容模式来禁用这些错误。</p>
</section>
<section id="usage">
<h2>语法<a class="headerlink" href="#usage" title="永久链接至标题"></a></h2>
<section id="requirements">
<h3>需求<a class="headerlink" href="#requirements" title="永久链接至标题"></a></h3>
<ul>
<li><p>C 编译器。你需要一个支持 C11 或 C++03 的编译器 <a class="footnote-reference brackets" href="#id3" id="id1">1</a></p>
<p>目前这意味着，你需要使用下面这些编译器：</p>
<ul class="simple">
<li><p>Windows 上的 MinGW64 C11 编译器，必须基于 gcc 11.2 或更高。如果没有找到可用的 C 编译器，它将被自动下载，这是推荐的安装方式，因为 Nuitka 也会为你升级它。</p></li>
<li><p>Windows <a class="footnote-reference brackets" href="#id4" id="id2">2</a> 上的 Visual Studio 2022 或更高版本，旧版本可以工作，但只支持商业用户。配置使用英语语言包以获得最佳效果（Nuitka 过滤掉垃圾输出，但只针对英语语言）。如果安装了，它将被默认使用。</p></li>
<li><p>在所有其他平台上，至少使用 5.1 版的 <code class="docutils literal notranslate"><span class="pre">gcc</span></code> 编译器，低于此版本的 <code class="docutils literal notranslate"><span class="pre">g++</span></code> 编译器至少使用 4.4 版作为替代。</p></li>
<li><p>macOS X 和大多数 FreeBSD 架构上的 <code class="docutils literal notranslate"><span class="pre">clang</span></code> 编译器。</p></li>
<li><p>在 Windows 上，如果 Visual Studio 安装程序提供，可以使用 Windows 上的 <code class="docutils literal notranslate"><span class="pre">clang-cl</span></code> 编译器”</p></li>
</ul>
</li>
<li><p>Python: Version 2.6, 2.7 or 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10</p>
<div class="admonition-for-python-3-3-3-4-and-only-those-we-need-other-python-version-as-a-compile-time-dependency admonition">
<p class="admonition-title">对于 Python 3.3/3.4 和只有这些，我们需要其他 Python 版本作为 <em>编译时</em> 的依赖。</p>
<p>Nuitka 本身与所有列出的版本完全兼容，但 Scons 作为内部使用的工具却不兼容。</p>
<p>对于这些版本，你 <em>需要</em> 也安装 Python2 或 Python3.5 或更高的版本，但只在编译时才需要。这是为了与 Scons（协调 C 语言编译）一起使用，它不支持与 Nuitka 一样的 Python 版本。</p>
<p>此外，在 Windows 上，不能使用 Python2，因为 <code class="docutils literal notranslate"><span class="pre">clcache</span></code> 不与它一起工作，需要安装 Python 3.5 或更高版本。</p>
<p>Nuitka 找到这些需要的 Python 版本（在 Windows 上通过注册表），只要它们被安装，你就不应该注意到它。</p>
</div>
<div class="admonition-moving-binaries-to-other-machines admonition">
<p class="admonition-title">将二进制文件转移到其他机器上</p>
<p>创建的二进制文件可以独立于 Python 的安装，使用 <code class="docutils literal notranslate"><span class="pre">--standalone</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--onefile</span></code> 选项，使之可执行。</p>
</div>
<div class="admonition-binary-filename-suffix admonition">
<p class="admonition-title">二进制文件名后缀</p>
<p>创建的二进制文件在 Windows 上有一个 <code class="docutils literal notranslate"><span class="pre">.exe</span></code> 的后缀。在其他平台上，它们没有独立模式的后缀，或 <code class="docutils literal notranslate"><span class="pre">.bin</span></code> 后缀，你可以自由删除或改变，或用 <code class="docutils literal notranslate"><span class="pre">-o</span></code> 选项指定。</p>
<p>添加加速模式的后缀只是为了确保原始脚本名称和二进制名称不会发生冲突，所以我们可以安全地进行覆盖而不破坏原始源文件。</p>
</div>
<div class="admonition-it-has-to-be-cpython-anaconda-python admonition">
<p class="admonition-title">它 <strong>必须</strong> 是 CPython，Anaconda Python。</p>
<p>你需要标准的 Python 实现，称为 “CPython”，来执行 Nuitka，因为它与它的实现细节紧密相连。</p>
</div>
<div class="admonition-it-cannot-be-from-windows-app-store admonition">
<p class="admonition-title">它不能从 Windows 应用商店获得。</p>
<p>众所周知，Windows 应用商店的 Python 肯定不工作，它被检查过。而在 macOS 上，”pyenv” 可能不会工作。</p>
</div>
</li>
<li><p>操作系统：Linux、FreeBSD、NetBSD、macOS X 和 Windows（32/64 位）。</p>
<p>其他的也可能起作用。预计可移植性总体上是好的，但如 Scons 的使用可能要进行调整。确保与 Windows 的 Python 和 C 编译器架构相匹配，否则你会得到神秘的错误信息。</p>
</li>
<li><p>架构：x86、x86_64（amd64）和 arm，可能还有更多的架构</p>
<p>其他架构预计也能工作，开箱即用，因为 Nuitka 一般不使用任何硬件特性。这些只是经过测试的、已知的好东西。我们欢迎反馈。一般来说，Debian 支持的架构也可以被认为是好的，并且经过测试。</p>
</li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>使用 gcc 5.x 或更高版本或任何 clang 版本，对这个 C11 的支持是必然的。</p>
<p>MSVC 的编译器还没有做到这一点。但作为一种变通方法，由于 C++03 语言标准与 C11 非常重合，然后在 C 编译器太旧的地方用它代替。Nuitka 在过去需要一个 C++ 编译器，但它改变了。</p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>从 <a class="reference external" href="https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx">https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx</a> 免费下载（社区版可以正常使用）。</p>
<p>建议使用最新版本，但不是必须的。另一方面，不需要除 Windows 10 之前的支持，它们可能对你有用，但对这些配置的支持只提供给商业用户。</p>
</dd>
</dl>
</section>
<section id="command-line">
<h3>命令行<a class="headerlink" href="#command-line" title="永久链接至标题"></a></h3>
<p>推荐执行 Nuitka 的方式是 <code class="docutils literal notranslate"><span class="pre">&lt;the_right_python&gt;</span> <span class="pre">-m</span> <span class="pre">nuitka</span></code>，以绝对确定你使用的是哪种 Python 解释器，这样更容易与 Nuitka 的内容相匹配。</p>
<p>其次是执行裸 Nuitka 的最佳方式，即从源码签出或存档，不需要改变环境变量，最值得注意的是，你完全不必为 Nuitka 弄乱 <code class="docutils literal notranslate"><span class="pre">PYTHONPATH</span></code>。你只需直接执行 <code class="docutils literal notranslate"><span class="pre">nuitka</span></code> 和 <code class="docutils literal notranslate"><span class="pre">nuitka-run</span></code> 脚本，不需要对环境做任何改变。你可能想把 <code class="docutils literal notranslate"><span class="pre">bin</span></code> 目录添加到你的 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> 中，以方便你使用，但这一步是可选的。</p>
<p>此外，如果你想用正确的解释器执行，在这种情况下，一定要执行 <code class="docutils literal notranslate"><span class="pre">&lt;the_right_python&gt;</span> <span class="pre">bin/nuitka</span></code>，就可以了。</p>
<div class="admonition-pick-the-right-interpreter admonition">
<p class="admonition-title">挑选合适的解释器</p>
<p>如果你遇到一个 <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>，你绝对是为你正在编译的程序选择了错误的解释器。</p>
</div>
<p>Nuitka 有一个 <code class="docutils literal notranslate"><span class="pre">--help</span></code> 选项来输出它能做什么。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>nuitka --help
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nuitka-run</span></code> 命令与 <code class="docutils literal notranslate"><span class="pre">nuitka</span></code> 相同，但有一个不同的默认值。它试图编译和直接执行一个 Python 脚本：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>nuitka-run --help
</pre></div>
</div>
<p>这个不同的选项是 <code class="docutils literal notranslate"><span class="pre">--run</span></code>，并在第一个非选项之后向创建的二进制文件传递参数，所以它与普通的 <code class="docutils literal notranslate"><span class="pre">python</span></code> 会做的事情有些类似。</p>
</section>
<section id="installation">
<h3>安装<a class="headerlink" href="#installation" title="永久链接至标题"></a></h3>
<p>For most systems, there will be packages on the <a class="reference external" href="https://nuitka.net/doc/download.html">download page</a> of Nuitka. But you can also
install it from source code as described above, but also like any other
Python program it can be installed via the normal <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span>
<span class="pre">install</span></code> routine.</p>
</section>
<section id="license">
<h3>许可证<a class="headerlink" href="#license" title="永久链接至标题"></a></h3>
<p>Nuitka is licensed under the Apache License, Version 2.0; you may not
use it except in compliance with the License.</p>
<p>You may obtain a copy of the License at
<a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
</section>
</section>
<section id="tutorial-setup-and-build-on-windows">
<h2>教程设置和在 Windows 上构建<a class="headerlink" href="#tutorial-setup-and-build-on-windows" title="永久链接至标题"></a></h2>
<p>这是基本步骤，如果你什么都没有安装，当然如果你有任何一个零件，就跳过它。</p>
<section id="setup">
<h3>设置<a class="headerlink" href="#setup" title="永久链接至标题"></a></h3>
<section id="install-python">
<h4>安装 Python<a class="headerlink" href="#install-python" title="永久链接至标题"></a></h4>
<ul class="simple">
<li><p>Download and install from <a class="reference external" href="https://www.python.org/downloads/windows">https://www.python.org/downloads/windows</a></p></li>
<li><p>Select one of <code class="docutils literal notranslate"><span class="pre">Windows</span> <span class="pre">x86-64</span> <span class="pre">web-based</span> <span class="pre">installer</span></code> (64 bits Python,
recommended) or <code class="docutils literal notranslate"><span class="pre">x86</span> <span class="pre">executable</span></code> (32 bits Python) installer.</p></li>
<li><p>Verify using command <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">--version</span></code>.</p></li>
</ul>
</section>
<section id="install-nuitka">
<h4>安装 Nuitka<a class="headerlink" href="#install-nuitka" title="永久链接至标题"></a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">nuitka</span></code></p></li>
<li><p>使用命令 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">nuitka</span> <span class="pre">--version</span></code> 进行验证。</p></li>
</ul>
</section>
</section>
<section id="write-some-code-and-test">
<h3>编写一些代码并进行测试<a class="headerlink" href="#write-some-code-and-test" title="永久链接至标题"></a></h3>
<section id="create-a-folder-for-the-python-code">
<h4>为 Python 代码创建一个文件夹<a class="headerlink" href="#create-a-folder-for-the-python-code" title="永久链接至标题"></a></h4>
<ul class="simple">
<li><p>mkdir HelloWorld</p></li>
<li><p>创建名为 <strong>hello.py</strong> 的 Python 文件</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">talk</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;Talk &quot;</span> <span class="o">+</span> <span class="n">message</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">talk</span><span class="p">(</span><span class="s2">&quot;Hello World&quot;</span><span class="p">))</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="test-your-program">
<h4>测试你的程序<a class="headerlink" href="#test-your-program" title="永久链接至标题"></a></h4>
<p>像平常那样做。在工作不正确的代码上运行 Nuitka，并不容易调试。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python hello.py
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="build-it-using">
<h4>采用以下方式构建<a class="headerlink" href="#build-it-using" title="永久链接至标题"></a></h4>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python -m nuitka hello.py
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这将提示你下载一个 C 语言缓存工具（以加速重复编译生成的 C 代码）和一个基于 MinGW64 的 C 语言编译器，除非你已经安装了合适的 MSVC。对这两个问题都说 <code class="docutils literal notranslate"><span class="pre">yes</span></code>。</p>
</div>
</section>
<section id="run-it">
<h4>运行它<a class="headerlink" href="#run-it" title="永久链接至标题"></a></h4>
<p>执行在 <code class="docutils literal notranslate"><span class="pre">hello.py</span></code> 附近创建的 <code class="docutils literal notranslate"><span class="pre">hello.exe</span></code>。</p>
</section>
<section id="distribute">
<h4>分发<a class="headerlink" href="#distribute" title="永久链接至标题"></a></h4>
<p>要分发，用 <code class="docutils literal notranslate"><span class="pre">--standalone</span></code> 选项构建，这不会输出一个单一的可执行文件，而是整个文件夹。将生成的 <code class="docutils literal notranslate"><span class="pre">hello.dist</span></code> 文件夹复制到另一台机器上并运行它。</p>
<p>你也可以尝试 <code class="docutils literal notranslate"><span class="pre">--onefile</span></code>，它确实创建了一个单一的文件，但在转向它之前，要确保单纯的独立运行，因为它将使调试更加困难，例如在数据文件丢失的情况下。</p>
</section>
</section>
</section>
<section id="use-cases">
<h2>用例<a class="headerlink" href="#use-cases" title="永久链接至标题"></a></h2>
<section id="use-case-1-program-compilation-with-all-modules-embedded">
<h3>用例 1 - 嵌入所有模块的程序编译<a class="headerlink" href="#use-case-1-program-compilation-with-all-modules-embedded" title="永久链接至标题"></a></h3>
<p>如果你想递归地编译整个程序，而不是只编译作为主程序的单个文件，可以这样做：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python -m nuitka --follow-imports program.py
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>有比 <code class="docutils literal notranslate"><span class="pre">--follow-imports</span></code>  更精细的控制。考虑一下 <code class="docutils literal notranslate"><span class="pre">nuitka</span> <span class="pre">--help</span></code> 的输出。在编译中包括更少的模块，而使用正常的 Python 进行编译，会使编译速度更快。</p>
</div>
<p>如果你有一个带有动态加载文件的源目录，即通过 <code class="docutils literal notranslate"><span class="pre">PYTHONPATH</span></code> 正常导入语句后无法找到的目录（这将是推荐的方式），你总是可以要求一个特定的目录也应包括在可执行文件中：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python -m nuitka --follow-imports --include-plugin-directory<span class="o">=</span>plugin_dir program.py
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果你不做任何动态导入，只需在编译时设置你的 <code class="docutils literal notranslate"><span class="pre">PYTHONPATH</span></code> 就可以了。</p>
<p>只有在你进行 Nuitka 无法预测的 <code class="docutils literal notranslate"><span class="pre">__import__()</span></code> 调用时，才使用 <code class="docutils literal notranslate"><span class="pre">--include-plugin-directory</span></code>，因为它们依赖于命令行参数。Nuitka 也会警告这些，并指出该选项。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>产生的文件名在 Windows 上将是 <code class="docutils literal notranslate"><span class="pre">program.exe</span></code>，在其他平台上是 <code class="docutils literal notranslate"><span class="pre">program.bin</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>产生的二进制文件仍然依赖于 CPython 和使用的 C 扩展模块被安装。</p>
<p>如果你想能够把它复制到另一台机器上，使用 <code class="docutils literal notranslate"><span class="pre">--standalone</span></code> 并复制创建的 <code class="docutils literal notranslate"><span class="pre">program.dist</span></code> 目录并执行放在里面的 <code class="docutils literal notranslate"><span class="pre">program.exe</span></code> （Windows）或 <code class="docutils literal notranslate"><span class="pre">program</span></code> （其他平台）”</p>
</div>
</section>
<section id="use-case-2-extension-module-compilation">
<h3>用例2 – 扩展模块的编译<a class="headerlink" href="#use-case-2-extension-module-compilation" title="永久链接至标题"></a></h3>
<p>如果你想编译一个单一的扩展模块，你所要做的就是这样：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python -m nuitka --module some_module.py
</pre></div>
</div>
<p>产生的文件 <code class="docutils literal notranslate"><span class="pre">some_module.so</span></code> 就可以代替 <code class="docutils literal notranslate"><span class="pre">some_module.py</span></code> 使用。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这是留给读者的一个练习，以找出如果两者都存在会发生什么。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>选项 <code class="docutils literal notranslate"><span class="pre">--follow-imports</span></code> 和其他变体也可以工作，但所包含的模块只有在你导入了 <code class="docutils literal notranslate"><span class="pre">some_module</span></code> 的名字之后才会变得可以导入。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>产生的扩展模块只能加载到同一版本的 CPython 中，并且不包括其他扩展模块。</p>
</div>
</section>
<section id="use-case-3-package-compilation">
<h3>用例3–软件包的编译<a class="headerlink" href="#use-case-3-package-compilation" title="永久链接至标题"></a></h3>
<p>如果你需要编译整个软件包并嵌入所有模块，那也是可行的，像这样使用 Nuitka：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python -m nuitka --module some_package --include-package<span class="o">=</span>some_package
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>包内容的包含需要手动提供，否则，包是空的。如果你愿意，你可以更具体一些，只包括一部分。位于包内的数据文件不会被这个过程嵌入，你需要用这种方法自己复制它们。</p>
</div>
</section>
<section id="use-case-4-program-distribution">
<h3>用例4–程序分发<a class="headerlink" href="#use-case-4-program-distribution" title="永久链接至标题"></a></h3>
<p>对于分发到其他系统，有一种独立模式，它产生一个文件夹，你可以指定 <code class="docutils literal notranslate"><span class="pre">--standalone</span></code>。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python -m nuitka --standalone program.py
</pre></div>
</div>
<p>在这种模式下，”跟随所有 import” 是默认的。你可以有选择地排除模块，特别是说 <code class="docutils literal notranslate"><span class="pre">--nofollow-import-to</span></code>，但是当在程序运行时试图导入它时，会出现 <code class="docutils literal notranslate"><span class="pre">ImportError</span></code>。</p>
<p>对于要包含的数据文件，使用选项 <code class="docutils literal notranslate"><span class="pre">--include-data-file=&lt;source&gt;=&lt;target&gt;</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">source</span></code> 是一个文件系统路径，但 <code class="docutils literal notranslate"><span class="pre">target</span></code> 必须指定为相对路径。对于单机版，你也可以手动复制它们，但这可能会做额外的检查，而对于单文件模式，不可能有手动复制。</p>
<p>要复制一个目录中的部分或全部文件，使用选项 <code class="docutils literal notranslate"><span class="pre">--include-data-file=/etc/*.txt=etc/</span></code>，你可以为这些文件指定 shell 模式，以及用尾部斜线表示的放置它们的子目录。</p>
<p>要复制整个文件夹的所有文件，你可以使用 <code class="docutils literal notranslate"><span class="pre">--include-data-dir=/path/to/images=images</span></code>，这将复制所有文件，包括潜在的子目录结构。你不能在这里进行过滤，也就是说，如果你只想要一个部分的拷贝，请事先删除文件。</p>
<p>对于包的数据，有一个更好的方法，使用 <code class="docutils literal notranslate"><span class="pre">--include-package-data</span></code>，它可以自动检测包的数据文件并将其复制过来。 它甚至可以接受 shell 风格的模式。</p>
<p>对于数据文件，你在很大程度上是靠自己的。Nuitka 记录了流行软件包所需要的数据，但它可能并不完整。如果你在这些方面遇到了问题，请提出来。</p>
<p>当这个工作完成后，如果你愿意，你可以使用 <code class="docutils literal notranslate"><span class="pre">onefile</span></code> 模式。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python -m nuitka --onefile program.py
</pre></div>
</div>
<p>这将创建一个单一的二进制文件，在 Linux 上，它甚至不会自己解压，而是将其内容作为一个文件系统循环回装，并使用该文件。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a binary that unpacks into a temporary folder</span>
python -m nuitka --onefile program.py
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>还有更多的平台特定选项，例如与图标、闪屏和版本信息有关的选项，请考虑 <code class="docutils literal notranslate"><span class="pre">--help</span></code> 输出以了解这些细节，并查看 “Good Looks” 部分。</p>
</div>
<p>同样，在 Windows 上，对于临时文件目录，默认使用用户的目录，然而这可以用 <code class="docutils literal notranslate"><span class="pre">--windows-onefile-tempdir-spec=%TEMP%\\onefile_%PID%_%TIME%</span></code> 中给出的路径规范来覆盖，这是默认的，断言创建的临时目录不能发生冲突。</p>
<p>目前，这些扩大的 token 可以使用。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 45%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Token</p></th>
<th class="head"><p>这将扩展到什么？</p></th>
<th class="head"><p>示例</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>%TEMP%</p></td>
<td><p>用户临时文件目录</p></td>
<td><p>C:Users...AppDataLocalsTemp</p></td>
</tr>
<tr class="row-odd"><td><p>%PID%</p></td>
<td><p>Process ID</p></td>
<td><p>2772</p></td>
</tr>
<tr class="row-even"><td><p>%TIME%</p></td>
<td><p>自纪元以来的时间，以秒为单位。</p></td>
<td><p>1299852985</p></td>
</tr>
<tr class="row-odd"><td><p>%PROGRAM%</p></td>
<td><p>可执行文件的完整程序文件名。</p></td>
<td><p>C:SomeWhereYourOnefile.exe</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>你有责任使提供的路径是唯一的，在 Windows 上，一个正在运行的程序将被锁定，虽然使用一个固定的文件夹名称是可能的，但在这种情况下，它可能导致锁定问题，即程序被重新启动。</p>
<p>通常你需要使用 <code class="docutils literal notranslate"><span class="pre">%TIME%</span></code> 或者至少使用 <code class="docutils literal notranslate"><span class="pre">%PID%</span></code> 来使路径唯一，这主要是针对使用情况的，例如你希望事物驻留在你选择的地方或者遵守你的命名惯例。</p>
</div>
</section>
<section id="use-case-5-setuptools-wheels">
<h3>用例5 - Setuptools 轮子<a class="headerlink" href="#use-case-5-setuptools-wheels" title="永久链接至标题"></a></h3>
<p>如果你有一个 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>、<code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> 驱动的为你的软件创建轮子的地方，把 Nuitka 用起来是非常容易的。</p>
<p>让我们从最常见的 <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 方法开始，你可以–当然是安装了 Nuitka，简单地执行目标 <code class="docutils literal notranslate"><span class="pre">bdist_nuitka</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code>。它接受所有的选项，并允许你指定一些特定于 Nuitka 的内容。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For setup.py if not you&#39;t use other build systems:</span>
<span class="n">setup</span><span class="p">(</span>
   <span class="o">...</span><span class="p">,</span>
   <span class="n">command_options</span><span class="o">=</span><span class="p">{</span>
      <span class="s1">&#39;nuitka&#39;</span><span class="p">:</span> <span class="p">{</span>
         <span class="c1"># boolean option, e.g. if you cared for C commands</span>
         <span class="s1">&#39;--show-scons&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
         <span class="c1"># options without value, e.g. enforce using Clang</span>
         <span class="s1">&#39;--clang&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;setup.py&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
         <span class="c1"># options with single values, e.g. enable a plugin of Nuitka</span>
         <span class="s1">&#39;--enable-plugin&#39;</span><span class="p">:</span> <span class="s1">&#39;anti-bloat&#39;</span><span class="p">,</span>
         <span class="c1"># options with several values, e.g. avoiding including modules</span>
         <span class="s1">&#39;--nofollow-import-to&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;*.tests&quot;</span><span class="p">,</span> <span class="s2">&quot;*.distutils&quot;</span><span class="p">],</span>
      <span class="p">}</span>
   <span class="p">},</span>
<span class="p">)</span>

<span class="c1"># For setup.py with other build systems:</span>
<span class="c1"># The tuple nature of the arguments is required by the dark nature of</span>
<span class="c1"># &quot;setuptools&quot; and plugins to it, that insist on full compatibility,</span>
<span class="c1"># e.g. &quot;setuptools_rust&quot;</span>

<span class="n">setup</span><span class="p">(</span>
   <span class="o">...</span><span class="p">,</span>
   <span class="n">command_options</span><span class="o">=</span><span class="p">{</span>
      <span class="s1">&#39;nuitka&#39;</span><span class="p">:</span> <span class="p">{</span>
         <span class="c1"># boolean option, e.g. if you cared for C commands</span>
         <span class="s1">&#39;--show-scons&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;setup.py&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
         <span class="c1"># options without value, e.g. enforce using Clang</span>
         <span class="s1">&#39;--clang&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;setup.py&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
         <span class="c1"># options with single values, e.g. enable a plugin of Nuitka</span>
         <span class="s1">&#39;--enable-plugin&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;setup.py&quot;</span><span class="p">,</span> <span class="s1">&#39;anti-bloat&#39;</span><span class="p">),</span>
         <span class="c1"># options with several values, e.g. avoiding including modules</span>
         <span class="s1">&#39;--nofollow-import-to&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="s2">&quot;setup.py&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;*.tests&quot;</span><span class="p">,</span> <span class="s2">&quot;*.distutils&quot;</span><span class="p">]),</span>
      <span class="p">}</span>
   <span class="p">},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>如果由于某种原因，你不能或不愿意改变目标，你可以把这个添加到你的 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 中。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For setup.py</span>
<span class="n">setup</span><span class="p">(</span>
   <span class="o">...</span><span class="p">,</span>
   <span class="n">build_with_nuitka</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>为了暂时禁止编译，你可以删除上面这一行，或者把它的值编辑成 <code class="docutils literal notranslate"><span class="pre">False</span></code>，或者从环境变量中取值，如果你选择的话，例如 <code class="docutils literal notranslate"><span class="pre">bool(os.environ.get(&quot;USE_NUITKA&quot;,</span> <span class="pre">&quot;True&quot;))</span></code>。这由你决定。</p>
</div>
<p>或者你可以把它放在你的 <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> 里。</p>
<div class="highlight-toml notranslate"><div class="highlight"><pre><span></span><span class="k">[metadata]</span><span class="w"></span>
<span class="n">build_with_nuitka</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">True</span><span class="w"></span>
</pre></div>
</div>
<p>最后，但不是最不重要的，Nuitka也支持新的 <code class="docutils literal notranslate"><span class="pre">build</span></code> meta，所以当你已经有一个 <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> 时，简单替换或添加这个值：</p>
<div class="highlight-toml notranslate"><div class="highlight"><pre><span></span><span class="k">[build-system]</span><span class="w"></span>
<span class="n">requires</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;setuptools&gt;=42&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;wheel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;nuitka&quot;</span><span class="p">]</span><span class="w"></span>
<span class="n">build-backend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;nuitka.distutils.Build&quot;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="tweaks">
<h2>调整<a class="headerlink" href="#tweaks" title="永久链接至标题"></a></h2>
<section id="icons">
<h3>图标<a class="headerlink" href="#icons" title="永久链接至标题"></a></h3>
<p>为了好看，你可以指定图标。在 Windows 上，你可以提供一个图标文件、一个可执行模板或一个 PNG 文件。所有这些都可以使用，甚至可以组合使用：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># These create binaries with icons:</span>
python -m nuitka --onefile --windows-icon-from-ico<span class="o">=</span>your-icon.png program.py
python -m nuitka --onefile --windows-icon-from-ico<span class="o">=</span>your-icon.ico program.py
python -m nuitka --onefile --windows-icon-template-exe<span class="o">=</span>your-icon.ico program.py
</pre></div>
</div>
</section>
<section id="splash-screen">
<h3>闪屏<a class="headerlink" href="#splash-screen" title="永久链接至标题"></a></h3>
<p>当程序启动缓慢时，飞溅的屏幕很有用。Onefile 启动本身并不慢，但你的程序可能很慢，而且你无法真正知道所用的电脑会有多快，所以拥有它们也许是个好主意。幸运的是，有了 Nuitka，它们很容易为 Windows 添加。</p>
<p>对于闪屏，你需要将其指定为 PNG 文件，然后确保在你的程序准备好后禁用闪屏，例如已经完成导入，准备好窗口，连接到数据库，并希望闪屏消失。这里我们使用项目语法将代码与创建结合起来，编译时要注意：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># nuitka-project: --onefile</span>
<span class="c1"># nuitka-project: --onefile-windows-splash-screen-image={MAIN_DIRECTORY}/Splash-Screen.png</span>

<span class="c1"># Whatever this is obviously</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Delaying startup by 10s...&quot;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># Use this code to signal the splash screen removal.</span>
<span class="k">if</span> <span class="s2">&quot;NUITKA_ONEFILE_PARENT&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
   <span class="n">splash_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
      <span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">(),</span>
      <span class="s2">&quot;onefile_</span><span class="si">%d</span><span class="s2">_splash_feedback.tmp&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;NUITKA_ONEFILE_PARENT&quot;</span><span class="p">]),</span>
   <span class="p">)</span>

   <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">splash_filename</span><span class="p">):</span>
      <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">splash_filename</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done... splash should be gone.&quot;</span><span class="p">)</span>
<span class="o">...</span>

<span class="c1"># Rest of your program goes here.</span>
</pre></div>
</div>
</section>
</section>
<section id="typical-problems">
<h2>典型问题<a class="headerlink" href="#typical-problems" title="永久链接至标题"></a></h2>
<section id="memory-issues-and-compiler-bugs">
<h3>内存问题和编译器错误<a class="headerlink" href="#memory-issues-and-compiler-bugs" title="永久链接至标题"></a></h3>
<p>有时 C 语言编译器会崩溃，说他们不能分配内存，或者一些输入被截断了，或者类似的错误信息，显然是来自于此。这里有几个选择，你可以探索一下：</p>
<section id="ask-nuitka-to-use-less-memory">
<h4>要求 Nuitka 使用更少的内存<a class="headerlink" href="#ask-nuitka-to-use-less-memory" title="永久链接至标题"></a></h4>
<p>有一个专门的选项 <code class="docutils literal notranslate"><span class="pre">--low-memory</span></code>，它影响了 Nuitka 的决策，使其在编译过程中避免大量使用内存，代价是增加编译时间。</p>
</section>
<section id="avoid-32-bit-c-compiler-assembler-memory-limits">
<h4>避免 32 位 C 语言编译器/汇编器的内存限制<a class="headerlink" href="#avoid-32-bit-c-compiler-assembler-memory-limits" title="永久链接至标题"></a></h4>
<p>不要使用 32 位的编译器，而要使用 64 位的。如果你在 Windows 上使用 32 位的 Python，你最应该使用 MSVC 作为 C 编译器，而不是 MinGW64。MSVC 是一个交叉编译器，在该平台上可以比 gcc 使用更多的内存。如果你不在 Windows 上，当然就没有这个选择了。另外，使用 64 位的 Python 也能工作。</p>
</section>
<section id="use-lto-compilation-or-not">
<h4>是否使用 LTO 编译<a class="headerlink" href="#use-lto-compilation-or-not" title="永久链接至标题"></a></h4>
<p>用 <code class="docutils literal notranslate"><span class="pre">--lto=yes</span></code> 或 <code class="docutils literal notranslate"><span class="pre">--lto=no</span></code>，你可以将 C 语言的编译切换到只产生字节码，而不是直接产生汇编码和机器码，但在最后做整个程序的优化。这将大大改变内存的使用，如果你的错误来自汇编器，使用 LTO 将最能避免这种情况。</p>
</section>
<section id="switch-the-c-compiler-to-clang">
<h4>将 C 语言编译器切换为 clang<a class="headerlink" href="#switch-the-c-compiler-to-clang" title="永久链接至标题"></a></h4>
<p>人们报告说，由于 gcc 的缺陷或内存占用，用 gcc 编译失败的程序在 Linux 上用 clang 可以正常工作。在 Windows 上，这可能仍然是一个选项，但需要先实现自动下载的 gcc，这将包含它。由于 MSVC 无论如何都是已知的更有效的内存，你应该去那里，如果你想使用 Clang，有支持 MSVC 中包含的那个。</p>
</section>
<section id="add-a-larger-swap-file-to-your-embedded-linux">
<h4>在你的嵌入式 Linux 中添加一个更大的交换文件<a class="headerlink" href="#add-a-larger-swap-file-to-your-embedded-linux" title="永久链接至标题"></a></h4>
<p>在内存不足的系统上，你需要使用交换空间。用完了可能是一个原因，增加更多的交换空间，或者根本就没有，可能会解决这个问题，但是要注意，当编译器来回交换时，会使事情变得非常慢，所以要先考虑下一个提示，或者在它的基础上考虑。</p>
</section>
<section id="limit-the-amount-of-compilation-jobs">
<h4>限制编译工作的数量<a class="headerlink" href="#limit-the-amount-of-compilation-jobs" title="永久链接至标题"></a></h4>
<p>使用 Nuitka 的 <code class="docutils literal notranslate"><span class="pre">--jobs</span></code> 选项，它不会同时启动许多 C 编译器实例，每个实例都在争夺稀缺的 RAM 资源。通过选择一个值，只有一个 C 编译器实例将被运行，在一个 8 核系统上，这将减少 8 倍的内存量，所以这是一个自然的选择。</p>
</section>
</section>
<section id="dynamic-sys-path">
<h3>动态 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code><a class="headerlink" href="#dynamic-sys-path" title="永久链接至标题"></a></h3>
<p>如果你的脚本修改了 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>，例如插入与源代码相对的目录，Nuitka 目前将无法看到这些。然而，如果你将 <code class="docutils literal notranslate"><span class="pre">PYTHONPATH</span></code> 设置为结果值，你就可以编译它了。</p>
</section>
<section id="missing-data-files-in-standalone">
<h3>单机版中缺少的数据文件<a class="headerlink" href="#missing-data-files-in-standalone" title="永久链接至标题"></a></h3>
<p>如果你的程序不能将数据归档，会导致各种不同的行为，例如，一个软件包可能会抱怨它的版本不对，因为 <code class="docutils literal notranslate"><span class="pre">VERSION</span></code> 文件检查默认为未知。没有图标文件或帮助文本，可能会引起奇怪的错误。</p>
<p>通常情况下，文件不存在的错误路径甚至是错误的，会暴露出编程错误，如未绑定局部变量。请仔细查看这些异常情况，牢记这可能是原因。如果你的程序没有独立运行，有可能是数据文件的原因。</p>
</section>
<section id="missing-dlls-in-standalone">
<h3>单机中缺少 DLLs<a class="headerlink" href="#missing-dlls-in-standalone" title="永久链接至标题"></a></h3>
<p>Nuitka 有处理复制 DLLs 的插件。对于 NumPy、SciPy、Tkinter 等。</p>
<p>这些需要特殊处理，以便能够在其他系统上运行。手动复制它们是不够的，而且会产生奇怪的错误。有时较新版本的软件包，特别是 NumPy 可能不被支持。在这种情况下，你将不得不提出一个问题，并使用较旧的版本。</p>
</section>
<section id="dependency-creep-in-standalone">
<h3>单机中的依赖性爬升<a class="headerlink" href="#dependency-creep-in-standalone" title="永久链接至标题"></a></h3>
<p>有些包是单一的 import，但对 Nuitka  来说，意味着要包括一千多个包（字面意思）。最典型的例子是 Pandas，它确实想插入和使用你能想象到的一切。多个框架用于语法高亮显示一切可以想象的东西，需要时间。</p>
<p>Nuitka 将来必须学习有效的缓存来处理这个问题。现在，你将不得不为这些处理巨大的编译时间。</p>
<p>现在，应该使用对抗依赖性蠕变的主要武器，即 <code class="docutils literal notranslate"><span class="pre">anti-bloat</span></code> 插件，它提供了有趣的能力，可以用来阻止不需要的导入，并在它们出现的地方给出一个错误。使用它，例如像这样 <code class="docutils literal notranslate"><span class="pre">--enable-plugin=anti-bloat</span> <span class="pre">--noinclude-pytest-mode=nofollow</span> <span class="pre">--noinclude-setuptools-mode=nofollow</span></code> 并查看其帮助输出。它可以为你选择的每一个模块，例如，也可以强迫 PyQt5 被视为独立模式的卸载。</p>
</section>
<section id="onefile-finding-files">
<h3>一体化文件：寻找文件<a class="headerlink" href="#onefile-finding-files" title="永久链接至标题"></a></h3>
<p>对于 onefile ，主模块的 <code class="docutils literal notranslate"><span class="pre">sys.argv[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 之间有差异，那是由于使用引导到临时位置造成的。第一个将是原始的可执行路径，而第二个将是 bootstrap 可执行文件解包到的临时或永久路径。数据文件将在后一个位置，你的原始环境文件将在前一个位置。</p>
<p>给定两个文件，一个是你希望在你的可执行文件附近的，一个是你希望在 onefile 二进制文件内的，像这样访问它们。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># This will find a file near your onefile.exe</span>
<span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;user-provided-file.txt&quot;</span><span class="p">))</span>
<span class="c1"># This will find a file inside your onefile.exe</span>
<span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s2">&quot;user-provided-file.txt&quot;</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="windows-programs-without-console-give-no-errors">
<h3>没有控制台的 Windows 程序不会出现错误<a class="headerlink" href="#windows-programs-without-console-give-no-errors" title="永久链接至标题"></a></h3>
<p>为了调试的目的，移除 <code class="docutils literal notranslate"><span class="pre">--windows-disable-console</span></code> 或使用选项 <code class="docutils literal notranslate"><span class="pre">--windows-force-stdout-spec</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--windows-force-stderr-spec</span></code>，其路径与上述 <code class="docutils literal notranslate"><span class="pre">--windows-onefile-tempdir-spec</span></code> 所记载的相同。</p>
</section>
</section>
<section id="tips">
<h2>小贴士<a class="headerlink" href="#tips" title="永久链接至标题"></a></h2>
<section id="nuitka-options-in-the-code">
<h3>代码中的 Nuitka 选项<a class="headerlink" href="#nuitka-options-in-the-code" title="永久链接至标题"></a></h3>
<p>支持条件性选项，以及使用预定义变量的选项，这是一个例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compilation mode, support OS specific.</span>
<span class="c1"># nuitka-project-if: {OS} in (&quot;Windows&quot;, &quot;Linux&quot;, &quot;Darwin&quot;, &quot;FreeBSD&quot;):</span>
<span class="c1">#    nuitka-project: --onefile</span>
<span class="c1"># nuitka-project-if: {OS} not in (&quot;Windows&quot;, &quot;Linux&quot;, &quot;Darwin&quot;, &quot;FreeBSD&quot;):</span>
<span class="c1">#    nuitka-project: --standalone</span>

<span class="c1"># The PySide2 plugin covers qt-plugins</span>
<span class="c1"># nuitka-project: --enable-plugin=pyside2</span>
<span class="c1"># nuitka-project: --include-qt-plugins=sensible,qml</span>
</pre></div>
</div>
<p>注释必须是一个行的开始，并且要使用缩进，以结束一个条件块，就像在 Python 中一样。目前除了上面演示的使用的关键字外，没有其他关键字。</p>
<p>你可以把任意的 Python 表达式放在那里，如果你想访问一个软件包的版本信息，你可以简单地使用 <code class="docutils literal notranslate"><span class="pre">__import__(&quot;module_name&quot;).__version__</span></code>，如果这将是需要的，例如启用或禁用某些 Nuitka 设置。Nuitka 所做的唯一一件事使得这不是 Python 表达式，就是为一组预先定义的变量扩展 <code class="docutils literal notranslate"><span class="pre">{variable}</span></code>：</p>
<p>带有支持的变量的表格：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 35%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>变量</p></th>
<th class="head"><p>这将扩展到什么？</p></th>
<th class="head"><p>示例</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>{OS}</p></td>
<td><p>使用的操作系统名称</p></td>
<td><p>Linux, Windows, Darwin, FreeBSD, OpenBSD</p></td>
</tr>
<tr class="row-odd"><td><p>{Version}</p></td>
<td><p>Nuitka 版本</p></td>
<td><p>e.g. (0, 6, 16)</p></td>
</tr>
<tr class="row-even"><td><p>{Commercial}</p></td>
<td><p>Nuitka 商业版本</p></td>
<td><p>e.g. (0, 9, 4)</p></td>
</tr>
<tr class="row-odd"><td><p>{Arch}</p></td>
<td><p>所用的架构</p></td>
<td><p>x86_64, arm64, etc.</p></td>
</tr>
<tr class="row-even"><td><p>{MAIN_DIRECTORY}</p></td>
<td><p>编译文件的目录</p></td>
<td><p>some_dir/maybe_relative</p></td>
</tr>
<tr class="row-odd"><td><p>{Flavor}</p></td>
<td><p>Python 的变体</p></td>
<td><p>例如：Debian Python, Anaconda Python</p></td>
</tr>
</tbody>
</table>
</section>
<section id="python-command-line-flags">
<h3>Python 命令行旗标<a class="headerlink" href="#python-command-line-flags" title="永久链接至标题"></a></h3>
<p>对于向 Python 传递 <code class="docutils literal notranslate"><span class="pre">-O</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-S</span></code> 这样的东西，对于你的编译程序，有一个命令行选项名为 <code class="docutils literal notranslate"><span class="pre">--python-flag=</span></code> ，它使 Nuitka 模拟这些选项。</p>
<p>支持最重要的那些，当然还可以增加更多。</p>
</section>
<section id="caching-compilation-results">
<h3>缓存编译结果<a class="headerlink" href="#caching-compilation-results" title="永久链接至标题"></a></h3>
<p>C 语言编译器，当用相同的输入文件调用时，将需要很长的时间和很多 CPU 来反复编译。确保你在使用 gcc 时安装和配置了 <code class="docutils literal notranslate"><span class="pre">ccache</span></code> （即使在 Windows 上）。它将使重复编译快得多，即使事情还不是很完美，即程序的改变会导致许多 C 文件的改变，需要重新编译而不是使用缓存的结果”</p>
<p>在 Windows 上，Nuitka 支持使用 <code class="docutils literal notranslate"><span class="pre">ccache.exe</span></code>，它将提供从官方来源下载，并自动进行。这是在 Windows 上使用它的推荐方式，因为其他版本可能会挂起。</p>
<p>如果在系统的 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> 中找到 <code class="docutils literal notranslate"><span class="pre">ccache</span></code> ，Nuitka 就会接收它，也可以通过设置 <code class="docutils literal notranslate"><span class="pre">NUITKA_CCACHE_BINARY</span></code> 为二进制的完整路径来提供，这是为了在 CI 系统中使用。</p>
<p>对于 MSVC 编译器和 ClangCL 设置，使用 <code class="docutils literal notranslate"><span class="pre">clcache</span></code> 是自动的，包含在 Nuitka 中。</p>
</section>
<section id="control-where-caches-live">
<h3>控制缓存的位置<a class="headerlink" href="#control-where-caches-live" title="永久链接至标题"></a></h3>
<p>各种缓存结果、下载、C 和 Nuitka 的缓存编译结果的存储，都是在一个与平台相关的目录中进行的，由 <code class="docutils literal notranslate"><span class="pre">appdirs</span></code> 包决定。然而，你可以通过设置环境变量 <code class="docutils literal notranslate"><span class="pre">NUITKA_CACHE_DIR</span></code> 来覆盖它的基本目录。这是为了在主目录不被持久化，但其他路径被持久化的环境中使用。</p>
</section>
<section id="runners">
<h3>运行器<a class="headerlink" href="#runners" title="永久链接至标题"></a></h3>
<p>避免运行 <code class="docutils literal notranslate"><span class="pre">nuitka</span></code> 二进制文件，而使用 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">nuitka</span></code> 会 100% 确定你在使用你认为的东西。使用错误的 Python 会使它对好的代码出现 <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>，对已安装的模块出现 <code class="docutils literal notranslate"><span class="pre">ImportError</span></code>。当你用 Python2 在 Python3 代码上运行 Nuitka 时，这种情况就会发生，反之亦然。通过明确地调用相同的 Python 解释器二进制文件，你可以完全避免这个问题。</p>
</section>
<section id="fastest-c-compilers">
<h3>最快的 C 语言编译器<a class="headerlink" href="#fastest-c-compilers" title="永久链接至标题"></a></h3>
<p>事实证明，在 Windows 上使用 64 位 Python 的 <code class="docutils literal notranslate"><span class="pre">pystone.exe</span></code> 的最快二进制文件，比使用 MinGW64 明显更快，大概有 20% 的提升。所以推荐使用它，而不是 MSVC。使用 Clang7 的 <code class="docutils literal notranslate"><span class="pre">clang-cl.exe</span></code> 比 MSVC 快，但仍然明显比 MinGW64 慢，而且会更难使用，所以不推荐使用。</p>
<p>在 Linux 上，对于 <code class="docutils literal notranslate"><span class="pre">pystone.bin</span></code>，由 <code class="docutils literal notranslate"><span class="pre">clang6</span></code> 产生的二进制文件比 <code class="docutils literal notranslate"><span class="pre">gcc-6.3</span></code> 快，但差距不大。由于 gcc 更多的时候已经安装了，所以现在建议使用它。</p>
<p>C 语言编译时间的差异还没有被研究。</p>
</section>
<section id="unexpected-slowdowns">
<h3>意外的速度减慢<a class="headerlink" href="#unexpected-slowdowns" title="永久链接至标题"></a></h3>
<p>使用Python DLL，就像标准的CPython那样，可能会导致意外的减速，例如在处理 Unicode 字符串的未编译的代码中。这是因为调用 DLL 而不是驻留在 DLL 中会导致开销，这甚至发生在 DLL 与本身，比一个 Python 全部包含在一个二进制文件中更慢。</p>
<p>所以如果可行的话，以静态链接为目标，目前只有 Anaconda Python 在非 Windows、Debian Python2、自编译的 Python（不要激活 <code class="docutils literal notranslate"><span class="pre">--enable-shared</span></code>，不需要），以及用 <code class="docutils literal notranslate"><span class="pre">pyenv</span></code> 创建的安装程序可以做到。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 Anaconda 上，你可能需要执行 <code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">install</span> <span class="pre">-c</span> <span class="pre">conda-forge</span> <span class="pre">libpython-static</span></code></p>
</div>
</section>
<section id="standalone-executables-and-dependencies">
<h3>独立的可执行文件和依赖性<a class="headerlink" href="#standalone-executables-and-dependencies" title="永久链接至标题"></a></h3>
<p>传统上，为 Windows 制作独立可执行文件的过程涉及使用外部依赖性运行器，以便将必要的库与编译的可执行文件一起复制到分发文件夹。</p>
<p>有很多方法可以发现缺少什么。不要手动复制东西到文件夹中，特别是不要复制 DLL，因为那是行不通的。相反，要做错误报告，让 Nuitka 正确处理这些问题。</p>
</section>
<section id="windows-errors-with-resources">
<h3>资源方面的 Windows 错误<a class="headerlink" href="#windows-errors-with-resources" title="永久链接至标题"></a></h3>
<p>在 Windows 上，Windows Defender 工具和 Windows 索引服务都会扫描刚创建的二进制文件，而 Nuitka 则想与之合作，例如添加更多资源，然后由于持有锁而随机阻止操作。请确保将你的编译阶段排除在这些服务之外。</p>
</section>
<section id="windows-standalone-program-redistribuation">
<h3>Windows 独立程序的重新分配<a class="headerlink" href="#windows-standalone-program-redistribuation" title="永久链接至标题"></a></h3>
<p>无论是用 MingW 还是 MSVC 编译，独立程序都对 Visual C Runtime 库有外部依赖性。Nuitka 试图通过从你的系统中复制这些依赖的 DLL 来运送它们。</p>
<p>从微软 Windows 10 开始，微软提供的 <code class="docutils literal notranslate"><span class="pre">ucrt.dll</span></code> （通用 C 语言运行库）重新钩住了对 <code class="docutils literal notranslate"><span class="pre">api-ms-crt-*.dll</span></code> 的调用。</p>
<p>对于早期的 Windows 平台（和 wine/ReactOS），你应该考虑在执行 Nuitka 独立编译程序之前安装 Visual C Runtime 库。</p>
<p>根据所使用的C语言编译器，你需要以下的 redist 版本：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 21%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Visual C 版本</p></th>
<th class="head"><p>Redist Year</p></th>
<th class="head"><p>CPython</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>14.2</p></td>
<td><p>2019</p></td>
<td><p>3.5, 3.6, 3.7, 3.8, 3.9, 3.10</p></td>
</tr>
<tr class="row-odd"><td><p>14.1</p></td>
<td><p>2017</p></td>
<td><p>3.5, 3.6, 3.7, 3.8</p></td>
</tr>
<tr class="row-even"><td><p>14.0</p></td>
<td><p>2015</p></td>
<td><p>3.5, 3.6, 3.7, 3.8</p></td>
</tr>
<tr class="row-odd"><td><p>10.0</p></td>
<td><p>2010</p></td>
<td><p>3.3, 3.4</p></td>
</tr>
<tr class="row-even"><td><p>9.0</p></td>
<td><p>2008</p></td>
<td><p>2.6, 2.7</p></td>
</tr>
</tbody>
</table>
<p>在使用 MingGW64 时，你需要以下的 redist 版本：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 21%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>MingGW64 版本</p></th>
<th class="head"><p>Redist Year</p></th>
<th class="head"><p>CPython</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>8.1.0</p></td>
<td><p>2015</p></td>
<td><p>3.5, 3.6, 3.7, 3.8, 3.9, 3.10</p></td>
</tr>
</tbody>
</table>
<p>一旦在目标系统上安装了相应的运行库，你可以从 Nuitka 编译的 dist 文件夹中删除所有 <code class="docutils literal notranslate"><span class="pre">api-ms-crt-*.dll</span></code> 文件。</p>
</section>
<section id="detecting-nuitka-at-run-time">
<h3>在运行时检测 Nuitka<a class="headerlink" href="#detecting-nuitka-at-run-time" title="永久链接至标题"></a></h3>
<p>它不像其他工具那样设置 <code class="docutils literal notranslate"><span class="pre">sys.frozen</span></code>。对于 Nuitka，我们有模块属性 <code class="docutils literal notranslate"><span class="pre">__compiled__</span></code> 来测试特定模块是否被编译。</p>
</section>
</section>
<section id="performance">
<h2>性能<a class="headerlink" href="#performance" title="永久链接至标题"></a></h2>
<p>本章概述了目前对 Nuitka 性能的期望。这是一项正在进行中的工作，会随着我们的进展而更新。目前性能测量的重点是 Python 2.7，但 3.x 将在以后跟进。</p>
<section id="pystone-results">
<h3>pystone 结果<a class="headerlink" href="#pystone-results" title="永久链接至标题"></a></h3>
<p>结果是这种输出的最高值，运行 pystone 1000 次，取最小值。这个想法是，最快的运行是最有意义的，并消除了使用高峰。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s2">&quot;Uncompiled Python2&quot;</span>
<span class="k">for</span> i <span class="k">in</span> <span class="o">{</span><span class="m">1</span>..100<span class="o">}</span><span class="p">;</span> <span class="k">do</span> <span class="nv">BENCH</span><span class="o">=</span><span class="m">1</span> python2 tests/benchmarks/pystone.py <span class="p">;</span> <span class="k">done</span> <span class="p">|</span> sort -n -r <span class="p">|</span> head -n <span class="m">1</span>
python2 -m nuitka --lto<span class="o">=</span>yes --pgo<span class="o">=</span>yes tests/benchmarks/pystone.py
<span class="nb">echo</span> <span class="s2">&quot;Compiled Python2&quot;</span>
<span class="k">for</span> i <span class="k">in</span> <span class="o">{</span><span class="m">1</span>..100<span class="o">}</span><span class="p">;</span> <span class="k">do</span> <span class="nv">BENCH</span><span class="o">=</span><span class="m">1</span> ./pystone.bin <span class="p">;</span> <span class="k">done</span> <span class="p">|</span> sort -n -r <span class="p">|</span> head -n <span class="m">1</span>

<span class="nb">echo</span> <span class="s2">&quot;Uncompiled Python3&quot;</span>
<span class="k">for</span> i <span class="k">in</span> <span class="o">{</span><span class="m">1</span>..100<span class="o">}</span><span class="p">;</span> <span class="k">do</span> <span class="nv">BENCH</span><span class="o">=</span><span class="m">1</span> python3 tests/benchmarks/pystone3.py <span class="p">;</span> <span class="k">done</span> <span class="p">|</span> sort -n -r <span class="p">|</span> head -n <span class="m">1</span>
python3 -m nuitka --lto<span class="o">=</span>yes --pgo<span class="o">=</span>yes tests/benchmarks/pystone3.py
<span class="nb">echo</span> <span class="s2">&quot;Compiled Python3&quot;</span>
<span class="k">for</span> i <span class="k">in</span> <span class="o">{</span><span class="m">1</span>..100<span class="o">}</span><span class="p">;</span> <span class="k">do</span> <span class="nv">BENCH</span><span class="o">=</span><span class="m">1</span> ./pystone3.bin <span class="p">;</span> <span class="k">done</span> <span class="p">|</span> sort -n -r <span class="p">|</span> head -n <span class="m">1</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 27%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Python</p></th>
<th class="head"><p>未编译</p></th>
<th class="head"><p>编译的 LTO</p></th>
<th class="head"><p>编译的 PGO</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Debian Python 2.7</p></td>
<td><p>137497.87 (1.000)</p></td>
<td><p>460995.20 (3.353)</p></td>
<td><p>503681.91 (3.663)</p></td>
</tr>
<tr class="row-odd"><td><p>Nuitka Python 2.7</p></td>
<td><p>144074.78 (1.048)</p></td>
<td><p>479271.51 (3.486)</p></td>
<td><p>511247.44 (3.718)</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="where-to-go-next">
<h2>下一步该去哪里<a class="headerlink" href="#where-to-go-next" title="永久链接至标题"></a></h2>
<p>记住，这个项目还没有完成。尽管 CPython 测试套件的工作近乎完美，但仍然需要更多的工作，特别是使它做更多的优化。试试吧。</p>
<section id="follow-me-on-twitter">
<h3>在 Twitter 上关注我<a class="headerlink" href="#follow-me-on-twitter" title="永久链接至标题"></a></h3>
<p>Nuitka announcements and interesting stuff is pointed to on the Twitter
account, but obviously with not too many details. <a class="reference external" href="https://twitter.com/KayHayen">&#64;KayHayen</a>.</p>
</section>
<section id="report-issues-or-bugs">
<h3>报告问题或 bug<a class="headerlink" href="#report-issues-or-bugs" title="永久链接至标题"></a></h3>
<p>如果你遇到任何问题、错误或想法，请访问 <a class="reference external" href="https://github.com/kayhayen/Nuitka/issues">Nuitka 错误跟踪器</a> 并报告它们。</p>
<p>报告 bug 的最佳做法：</p>
<ul>
<li><p>请在你的报告中始终包括以下信息，用于底层的 Python 版本。你可以很容易地把它复制&amp;粘贴到你的报告中。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python -m nuitka --version
</pre></div>
</div>
</li>
<li><p>尽量使你的例子最小化。也就是说，尽可能地删除那些对问题没有贡献的代码。最好是想出一个小的复制程序来说明这个问题，使用 <code class="docutils literal notranslate"><span class="pre">print</span></code>，当该程序运行时，会有不同的结果。</p></li>
<li><p>如果问题是假性发生的（即不是每次都发生），尝试将环境变量 <code class="docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code> 设为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，禁用哈希随机化。如果这使问题消失，试着以 1 的步骤增加到一个哈希种子值，使它每次都发生，把它包括在你的报告中。</p></li>
<li><p>不要在你的报告中包括创建的代码。考虑到适当的输入，它是多余的，如果没有改变 Python 或 Nuitka 源并重新运行的能力，我不太可能看它。</p></li>
<li><p>不要发送文本的截图，那是不好的和懒惰的。相反，从控制台捕捉文本输出。</p></li>
</ul>
</section>
<section id="word-of-warning">
<h3>警示语<a class="headerlink" href="#word-of-warning" title="永久链接至标题"></a></h3>
<p>考虑慎重使用这个软件。尽管在发布前进行了许多测试，但事情还是有可能发生变化。我们非常欢迎你对 Nuitka 的反馈和补丁。</p>
</section>
</section>
<section id="join-nuitka">
<h2>加入 Nuitka<a class="headerlink" href="#join-nuitka" title="永久链接至标题"></a></h2>
<p>我们非常欢迎你加入 Nuitka 的发展，并在所有的小事和大事上帮助完成这个项目。</p>
<p>Nuitka 的开发发生在 git 中。我们目前有以下 3 个分支：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">main</span></code></p>
<p>这个分支包含稳定版，只对其进行错误的热修复。它应该在任何时候都能工作，并受到支持。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">develop</span></code></p>
<p>这个分支包含正在进行的开发。它有时可能包含一些小的退步，但也有新的功能。在这个分支上，集成工作已经完成，而新功能可能在特性分支上开发。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">factory</span></code></p>
<p>这个分支包含未完成的和不完整的工作。它经常受到 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">rebase</span></code> 和公共暂存地的影响，我的开发分支的工作首先在这里进行。它只用于测试，建议在此基础上进行自己的开发。当更新它时，你经常会遇到合并冲突。只需通过做 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">origin/factory</span></code> 来解决这些问题，然后切换到最新版本。</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference external" href="https://nuitka.net/doc/developer-manual.html">开发者手册</a> 解释了编码规则，使用的分支模型，与功能分支和热修复版本，Nuitka 设计等等。考虑阅读它以成为一个贡献者。这份文档是为 Nuitka 用户准备的。</p>
</div>
</section>
<section id="donations">
<h2>奉献<a class="headerlink" href="#donations" title="永久链接至标题"></a></h2>
<p>Should you feel that you cannot help Nuitka directly, but still want to
support, please consider <a class="reference external" href="https://nuitka.net/pages/donations.html">making a donation</a> and help this way.</p>
</section>
<section id="unsupported-functionality">
<h2>不支持的功能<a class="headerlink" href="#unsupported-functionality" title="永久链接至标题"></a></h2>
<section id="the-co-code-attribute-of-code-objects">
<h3>代码对象的 <code class="docutils literal notranslate"><span class="pre">co_code</span></code> 属性<a class="headerlink" href="#the-co-code-attribute-of-code-objects" title="永久链接至标题"></a></h3>
<p>对于本地编译的函数，代码对象是空的。Nuitka 的编译函数对象没有字节码，所以没有办法提供。</p>
</section>
<section id="pdb">
<h3>PDB<a class="headerlink" href="#pdb" title="永久链接至标题"></a></h3>
<p>没有对编译后的函数进行跟踪，也没有对调试器进行跟踪。</p>
</section>
</section>
<section id="optimization">
<h2>优化<a class="headerlink" href="#optimization" title="永久链接至标题"></a></h2>
<section id="constant-folding">
<h3>常量叠算<a class="headerlink" href="#constant-folding" title="永久链接至标题"></a></h3>
<p>最重要的优化形式是常量叠算（Constant Folding）。这时，一个操作可以在编译时被完全预测。目前，Nuitka 为一些内建程序做了这些工作（但还不是全部，非常欢迎有人更仔细地研究这个问题！），它为二元/一元运算和比较等做了这些工作。</p>
<p>目前承认的常数：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="o">+</span> <span class="mi">6</span>  <span class="c1"># binary operations</span>
<span class="ow">not</span> <span class="mi">7</span>  <span class="c1"># unary operations</span>
<span class="mi">5</span> <span class="o">&lt;</span> <span class="mi">6</span>  <span class="c1"># comparisons</span>
<span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># built-ins</span>
</pre></div>
</div>
<p>字面值是常量的一个明显来源，但也很可能是其他优化步骤，如常量传播或函数内联。所以这一点不应该被低估，也是成功优化的一个非常重要的步骤。每一个产生常量的选项都可能对生成的代码质量产生很大的影响”</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>常量的折叠被认为已经实现，但它可能是不完整的，因为不是所有可能的情况都被抓住。当你在 Nuitka 中发现一个只有常量输入且没有折叠的操作时，请将其作为一个错误报告。</p>
</div>
</section>
<section id="constant-propagation">
<h3>常量传播<a class="headerlink" href="#constant-propagation" title="永久链接至标题"></a></h3>
<p>在优化的核心，是试图在运行时确定变量的值和预测赋值的情况。它决定了它们的输入是否是常数或类似的值。一个表达式，例如一个模块变量访问，一个昂贵的操作，可能在整个函数范围的模块中是恒定的，那么就不需要或者不需要重复的模块变量查找。</p>
<p>考虑到例如模块属性 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>，它很可能只被读取，所以它的值可以在编译时被预测为一个已知的常量字符串。然后，这可以作为常量折叠的输入。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Your test code might be here</span>
    <span class="n">use_something_not_use_by_program</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>在模块属性中，目前只有 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 被实际优化。同样可能的是，至少有 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code>。在未来，随着 SSA 扩展到模块变量，这一点可能会得到改善。</p>
</div>
</section>
<section id="built-in-name-lookups">
<h3>内置名称查询<a class="headerlink" href="#built-in-name-lookups" title="永久链接至标题"></a></h3>
<p>另外，如果内置的异常名称引用被用作模块级的只读变量，则会被优化：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">something</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># The ValueError is a slow global name lookup normally.</span>
    <span class="k">pass</span>
</pre></div>
</div>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>这适用于所有的内置名称。当对这样的名字进行赋值时，或者它甚至是本地的，那么，当然就不做了。</p>
</div>
</section>
<section id="built-in-call-prediction">
<h3>内置回调预测<a class="headerlink" href="#built-in-call-prediction" title="永久链接至标题"></a></h3>
<p>对于像 <code class="docutils literal notranslate"><span class="pre">type</span></code>、<code class="docutils literal notranslate"><span class="pre">len</span></code> 或 <code class="docutils literal notranslate"><span class="pre">range</span></code> 这样的内置调用，通常可以在编译时预测结果，特别是对于常数输入，结果值往往可以由 Nuitka 预先计算出来。它可以简单地确定结果或引发的异常，并用该值替换内置调用，允许更多的常量折叠或减少代码路径。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">)</span>  <span class="c1"># predictable result, builtin type str.</span>
<span class="nb">len</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># predictable result</span>
<span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># predictable result</span>
<span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># predictable exception, range raises due to 0.</span>
</pre></div>
</div>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>内置的回调预测被认为已经实现。我们可以在编译时简单地模拟调用，并使用其结果或引发的异常。但我们可能还没有涵盖所有的内置程序。</p>
</div>
<p>有时，当一个内置的结果很大时，不应该预测它的结果。例如，调用 <code class="docutils literal notranslate"><span class="pre">range()</span></code> 可能会给出太大的值，无法将结果纳入二进制。那么就不做了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>  <span class="c1"># We do not want this one to be expanded</span>
</pre></div>
</div>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>这被认为是基本实现了。请为那些预先计算，但不应该由 Nuitka 在编译时用特定值计算的内置程序提出错误。</p>
</div>
</section>
<section id="conditional-statement-prediction">
<h3>条件性声明的预测<a class="headerlink" href="#conditional-statement-prediction" title="永久链接至标题"></a></h3>
<p>对于条件性语句，有些分支可能永远不会被采纳，因为条件是可以预测的。在这些情况下，不采取的分支和条件检查被删除。</p>
<p>这通常可以预测这样的代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Your test code might be here</span>
    <span class="n">use_something_not_use_by_program</span><span class="p">()</span>
</pre></div>
</div>
<p>或</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
    <span class="c1"># Your deactivated code might be here</span>
    <span class="n">use_something_not_use_by_program</span><span class="p">()</span>
</pre></div>
</div>
<p>它也将受益于不断的传播，或使其成为可能，因为一旦一些分支被删除，其他事情可能变得更可预测，所以这可以引发其他优化成为可能。</p>
<p>每删除一个分支都会使优化更有可能。随着一些代码分支的删除，访问模式可能更加友好。想象一下，例如，一个函数只在被删除的分支中被调用。有可能完全删除它，而这也可能产生其他后果。</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>这被认为已经实现了，但为了获得最大的利益，需要在编译时确定更多的常数。</p>
</div>
</section>
<section id="exception-propagation">
<h3>异常传播<a class="headerlink" href="#exception-propagation" title="永久链接至标题"></a></h3>
<p>对于在编译时确定的异常，有一个表达式会简单地引发异常。这些可以向上传播，收集潜在的 “副作用”，即在它发生之前已经执行的表达式的一部分，并且仍然要执行。</p>
<p>请考虑以下代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">side_effect_having</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">something_else</span><span class="p">())</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">(1</span> <span class="pre">/</span> <span class="pre">0)</span></code> can be predicted to raise a <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>
exception, which will be propagated through the <code class="docutils literal notranslate"><span class="pre">+</span></code> operation. That
part is just Constant Propagation as normal.</p>
<p>The call <code class="docutils literal notranslate"><span class="pre">side_effect_having()</span></code> will have to be retained though, but
the <code class="docutils literal notranslate"><span class="pre">print</span></code> does not and can be turned into an explicit raise. The
statement sequence can then be aborted and as such the
<code class="docutils literal notranslate"><span class="pre">something_else</span></code> call needs no code generation or consideration
anymore.</p>
<p>To that end, Nuitka works with a special node that raises an exception
and is wrapped with a so-called “side_effects” expression, but yet can
be used in the code as an expression having a value.</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>The propagation of exceptions is mostly implemented but needs
handling in every kind of operations, and not all of them might do it
already. As work progresses or examples arise, the coverage will be
extended. Feel free to generate bug reports with non-working
examples.</p>
</div>
</section>
<section id="exception-scope-reduction">
<h3>Exception Scope Reduction<a class="headerlink" href="#exception-scope-reduction" title="永久链接至标题"></a></h3>
<p>请考虑以下代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Will not be executed&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">try</span></code> block is bigger than it needs to be. The statement <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">8</span></code>
cannot cause a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> to be raised. As such it can be moved to
outside the try without any risk.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="mi">8</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Will not be executed&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>This is considered done. For every kind of operation, we trace if it
may raise an exception. We do however <em>not</em> track properly yet, what
can do a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> and what cannot.</p>
</div>
</section>
<section id="exception-block-inlining">
<h3>Exception Block Inlining<a class="headerlink" href="#exception-block-inlining" title="永久链接至标题"></a></h3>
<p>With the exception propagation, it then becomes possible to transform
this code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Will not be executed!&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;range() step argument must not be zero&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>Which then can be lowered in complexity by avoiding the raise and catch
of the exception, making it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;range() step argument must not be zero&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>This is not implemented yet.</p>
</div>
</section>
<section id="empty-branch-removal">
<h3>Empty Branch Removal<a class="headerlink" href="#empty-branch-removal" title="永久链接至标题"></a></h3>
<p>For loops and conditional statements that contain only code without
effect, it should be possible to remove the whole construct:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The loop could be removed, at maximum, it should be considered an
assignment of variable <code class="docutils literal notranslate"><span class="pre">i</span></code> to <code class="docutils literal notranslate"><span class="pre">999</span></code> and no more.</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>This is not implemented yet, as it requires us to track iterators,
and their side effects, as well as loop values, and exit conditions.
Too much yet, but we will get there.</p>
</div>
<p>Another example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">side_effect_free</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The condition check should be removed in this case, as its evaluation is
not needed. It may be difficult to predict that <code class="docutils literal notranslate"><span class="pre">side_effect_free</span></code> has
no side effects, but many times this might be possible.</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>This is considered implemented. The conditional statement nature is
removed if both branches are empty, only the condition is evaluated
and checked for truth (in cases that could raise an exception).</p>
</div>
</section>
<section id="unpacking-prediction">
<h3>Unpacking Prediction<a class="headerlink" href="#unpacking-prediction" title="永久链接至标题"></a></h3>
<p>When the length of the right-hand side of an assignment to a sequence
can be predicted, the unpacking can be replaced with multiple
assignments.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">side_effect_free</span><span class="p">(),</span> <span class="mi">3</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">side_effect_free</span><span class="p">()</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>This is of course only really safe if the left-hand side cannot raise an
exception while building the assignment targets.</p>
<p>We do this now, but only for constants, because we currently have no
ability to predict if an expression can raise an exception or not.</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>Not implemented yet. Will need us to see through the unpacking of
what is an iteration over a tuple, we created ourselves. We are not
there yet, but we will get there.</p>
</div>
</section>
<section id="built-in-type-inference">
<h3>Built-in Type Inference<a class="headerlink" href="#built-in-type-inference" title="永久链接至标题"></a></h3>
<p>When a construct like <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">xrange()</span></code> or <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">range()</span></code> is used, it is
possible to know what the iteration does and represent that so that
iterator users can use that instead.</p>
<p>I consider that:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="n">something</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>could translate <code class="docutils literal notranslate"><span class="pre">xrange(1000)</span></code> into an object of a special class that
does the integer looping more efficiently. In case <code class="docutils literal notranslate"><span class="pre">i</span></code> is only
assigned from there, this could be a nice case for a dedicated class.</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>Future work, not even started.</p>
</div>
</section>
<section id="quicker-function-calls">
<h3>Quicker Function Calls<a class="headerlink" href="#quicker-function-calls" title="永久链接至标题"></a></h3>
<p>Functions are structured so that their parameter parsing and <code class="docutils literal notranslate"><span class="pre">tp_call</span></code>
interface is separate from the actual function code. This way the call
can be optimized away. One problem is that the evaluation order can
differ.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>


<span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">get1</span><span class="p">(),</span> <span class="n">b</span><span class="o">=</span><span class="n">get2</span><span class="p">(),</span> <span class="n">a</span><span class="o">=</span><span class="n">get3</span><span class="p">())</span>
</pre></div>
</div>
<p>This will have to evaluate first <code class="docutils literal notranslate"><span class="pre">get1()</span></code>, then <code class="docutils literal notranslate"><span class="pre">get2()</span></code> and only
then <code class="docutils literal notranslate"><span class="pre">get3()</span></code> and then make the function call with these values.</p>
<p>Therefore it will be necessary to have a staging of the parameters
before making the actual call, to avoid a re-ordering of the calls to
<code class="docutils literal notranslate"><span class="pre">get1()</span></code>, <code class="docutils literal notranslate"><span class="pre">get2()</span></code>, and <code class="docutils literal notranslate"><span class="pre">get3()</span></code>.</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>Not even started. A re-formulation that avoids the dictionary to call
the function, and instead uses temporary variables appears to be
relatively straight forward once we do that kind of parameter
analysis.</p>
</div>
</section>
<section id="lowering-of-iterated-container-types">
<h3>Lowering of iterated Container Types<a class="headerlink" href="#lowering-of-iterated-container-types" title="永久链接至标题"></a></h3>
<p>In some cases, accesses to <code class="docutils literal notranslate"><span class="pre">list</span></code> constants can become <code class="docutils literal notranslate"><span class="pre">tuple</span></code>
constants instead.</p>
<p>Consider that:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]:</span>
    <span class="n">something</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Can be optimized into this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">something</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>This allows for simpler, faster code to be generated, and fewer checks
needed, because e.g. the <code class="docutils literal notranslate"><span class="pre">tuple</span></code> is clearly immutable, whereas the
<code class="docutils literal notranslate"><span class="pre">list</span></code> needs a check to assert that. This is also possible for sets.</p>
<div class="admonition-status admonition">
<p class="admonition-title">状态</p>
<p>Implemented, even works for non-constants. Needs other optimization
to become generally useful, and will itself help other optimization
to become possible. This allows us to e.g. only treat iteration over
tuples, and not care about sets.</p>
</div>
<p>In theory, something similar is also possible for <code class="docutils literal notranslate"><span class="pre">dict</span></code>. For the
later, it will be non-trivial though to maintain the order of execution
without temporary values introduced. The same thing is done for pure
constants of these types, they change to <code class="docutils literal notranslate"><span class="pre">tuple</span></code> values when iterated.</p>
</section>
</section>
<section id="updates-for-this-manual">
<h2>更新手册<a class="headerlink" href="#updates-for-this-manual" title="永久链接至标题"></a></h2>
<p>这份文件是用 REST 写的。这是一种 ASCII 格式，人类可以阅读，但很容易用于生成 PDF 或 HTML 文档。</p>
<p>你可以在以下网站找到当前版本：<a class="reference external" href="https://nuitka.net/doc/user-manual.html">https://nuitka.net/doc/user-manual.html</a></p>
<p>当前 PDF 版本：<a class="reference external" href="https://nuitka.net/doc/README.pdf">https://nuitka.net/doc/README.pdf</a></p>
</section>
</section>

<div class="section">
   
</div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, Kay Hayen and Nuitka Contributors.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>